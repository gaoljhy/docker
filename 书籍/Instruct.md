容器与管理程序虚拟化（hypervisor virtualization，HV）有所不同，管理程序虚拟化通过中间层将一台或多台独立的机器虚拟运行在物理硬件之上，而容器则是直接运行在操作系统内核之上的用户空间。因此容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行在同一台宿主机上。

由于“客居”于操作系统，容器只能运行与底层宿主机相同或相似的操作系统。

对Docker来说，它得益于现代Linux内核特性，control group、namespace技术，容器和宿主机之间的隔离更加彻底，容器有独立的网络和存储栈，还拥有自己的资源管理能力，使得同一台宿主机中的多个容器可以共存。

和传统的虚拟化以及半虚拟化（paravirtualization）相比，容器运行不需要模拟层（emulation layer）和管理层（hypervisor layer），而是使用操作系统的系统调用接口。这降低了运行单个容器所需的开销，也使得宿主机中可以运行更多的容器。

#### Docker简介

Docker是一个能够把开发的应用程序自动部署到容器的开源引擎。由Docker公司的团队编写，基于Apache 2.0 开源授权协议发行。

Docker的特别之处在于，Docker在虚拟化的容器执行环境中增加了一个应用程序部署引擎。该引擎的目标就是提供一个轻量、快速的环境，能够运行开发者的程序，并方便高效地将程序从开发者的笔记本部署到测试环境，然后再部署到生产环境。Docker极其简洁，它所需的全部环境只是一台仅仅安装了兼容版本的Linux内核和二进制文件最小限度的宿主机。Docker的目标就是要提供以下这些内容。

* 提供一个简单、轻量的建模方式  
  Docker上手非常快，用户只需要几分钟，就可以把自己的程序Docker化。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速。随后就可以创建容器来运行应用程序了。大多数Docker容器只需不到1秒钟即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，是用户可以尽可能充分地利用系统资源。

* 职责的逻辑分离  
  使用Docker，开发用户只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境的一致性，降低了“开发正常，肯定是运维的问题”的风险。

* 快速、高效的开发生命周期  
  Docker 的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。

* 鼓励使用面向服务的架构
  Docker鼓励面向服务的架构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单。

#### Docker组件

Docker 和核心组件

* Docker 客户端和服务器
* Docker 镜像
* Registry
* Docker容器

#### Docker客户端和服务器

Docker是一个客户-服务器（C/S）建构的程序。Docker客户端只需向Docker服务器或守护进程发出请求，服务器或守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具docker以及一整套 RESTful API。你可以在同一台宿主机上运行Docker 守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的运程Docker守护进程

![](/assets/3422FA16-8375-4EDE-815E-7B62ACF20B50.png)



#### Docker镜像

镜像是构建Docker世界的基石，用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合（Union）文件系统的一种层式的结构，由一系列指令一步一步构建出来。例如：

* 添加一个文件
* 执行一个命令
* 打开一个端口

也可以把镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。

#### Registry

Docker用 Registry来保存用户构建的镜像。Registry 分为公共和私有两种。

Docker公司运营的公共Registry叫做 Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像。

也可以假设自己的私有Registry。

#### 容器

Docker可以构建和部署容器，只需要把自己的应用程序或服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。可以认为，镜像是Docker生命周期中的构建或打包阶段，而容器则是启动或执行阶段。

总结起来，Docker容器就是：

* 一个镜像格式；
* 一系列标准的操作；
* 一个执行环境

Docker 借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将一个模型运用到自己的设计哲学中，唯一不同的是：集装箱运输货物，而Docker运输软件。

每个容器都包含一个软件镜像，也就是容器的“货物”，而且与真正的货物一样，容器里的软件镜像可以进行一些操作。例如，镜像可以被创建、启动、关闭、重启以及销毁。

和集装箱一样Docker在执行上述操作时，并不关心容器中到底塞进了什么，它不管里面是Web服务器，还是数据库，或是应用程序服务器什么的。所有容器都按照相同的方式将内容“装载”进去。

Docker 也不关心你要把容器运到何方：你可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，再把容器部署到Amazon EC2主机的集群中去。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。

使用Docker，可以快速构建一个应用程序服务器、一个消息总线、一套实用工具、一个持续集成（continuous integration，CI）测试环境或者任意一种应用程序、服务或工具。

#### Docker可以做什么

容器提供的隔离性，可以为各种测试提供很好的sandbox环境，容器本身就具有“标准性”的特征，非常适合为服务创建构建块。

* 加速本地开发和构建流程，使其更加高效、更加轻量化。本地开发人员可以构建、运行并分享Docker容器。容器可以在开发环境中构建，然后提交到测试环境中，并最终进入生产环境

* 能够让独立服务或应用程序在不同的环境中得到相同的运行结果。这点在面向服务的架构和重度依赖微型服务的部署中尤其实用

* 用Docker创建隔离的环境来进行测试。例如，用Jenkins CI这样的持续集成工具启动一个用于测试的容器。

* Docker可以让开发者现在本机构建一个复杂的程序或架构来进行测试，而不是一开始就在生产环境部署、测试

* 构建一个多用户的PaaS（平台即服务）基础设施

* 为开发、测试提供一个轻量级的独立sandbox环境，或将独立的sandbox环境用于技术教学。

* 提供SaaS（软件即服务）应用程序，如 Memcached既服务

#### Docker的技术组件

Docker可以运行在任何安装了现代Linux内核的x64主机上，推荐内核版本3.8或更高。

一个原生的Linux容器格式，Docker中称为libcontainer或者lxc。libcontainer格式现在是Docker容器的默认格式。

Linxu内核的命名空间（namespace），用于隔离文件系统、进程和网络。

* 文件系统隔离：每个容器都有自己的root文件系统
* 进程隔离：每个容器都运行在自己的进程环境中
* 网络隔离：容器间的虚拟网络接口和IP地址都是分开的
* 资源隔离和分组：使用cgroup（control group，Linux的内核特性之一）将CPU和内存等资源独立分配给每个Docker容器
* 写时拷贝：文件系统都是通过写时拷贝创建，这就意味着文件系统是分层的、快速的，而且占用的磁盘空间更小。
* 日志：容器产生的STDOUT、STDERR和STDIN这些IO都会被收集并记入日志，用来进行日志分析和故障排除。
* 交互式shell：用户可以创建一个tty终端，将其连接到STDIN，为容器提供一个交互式shell

#### 为什么使用容器技术

在没有用容器化技术之前，我们存在这些问题：

* 资源利用率问题

不同业务场景对资源的需求是不一样的，有CPU密集型、内存密集型、网络密集型，这就可能会导致资源利用率不合理的问题，比如一个机器上部署的服务都是网络密集型，那么CPU资源和内存资源就都浪费了。有些业务可能只聚焦于服务本身而忽略机器资源利用率的问题。

* 混合部署交叉影响

对于线上服务，一台机器要混合部署多个服务，那么服务之间可能存在相互影响的情况，比如：一个服务由于某些原因突然网络流量暴涨，可能把整个机器的带宽都打满，那么其他服务就会受到影响。

* 扩/缩容效率低

当业务节点需要进行扩/缩时，从机器下线到应用部署、测试，周期较长。当业务遇到突发流量高峰时，机器到手部署后，可能流量高峰已经过去了。

* 多环境代码不一致

由于过去内部开发流程的不规范，存在一些问题，业务提测的代码在测试环境测试完毕后，在沙箱可能会进行修改、调整，然后再打包上线。这就会导致测试的代码和线上运行的代码是不一致的，增加了服务上线的风险，也增加了线上服务故障排查的难度。

* 缺少稳定的线下测试环境

在测试过程中，会遇到一个问题，服务依赖的其他下游服务都没有提供稳定的测试环境，这导致无法在测试环境模拟整个线上流程进行测试，所以很多测试同学会用线上服务进行测试，这里有很高的潜在风险。

为了解决上述问题，架构线云团队进行了技术选型与反复论证，最终决定使用Docker容器技术。

